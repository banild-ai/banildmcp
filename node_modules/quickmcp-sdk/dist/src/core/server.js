/**
 * Core QuickMCP Server - Simplified MCP server implementation
 */
import { McpServer, ResourceTemplate } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import { z } from "zod";
import express from "express";
import cors from "cors";
import { randomUUID } from "node:crypto";
import { logger } from '../utils/logger.js';
import { Response } from '../utils/response.js';
/**
 * Registry for storing all registered handlers
 */
class HandlerRegistry {
    tools = new Map();
    resources = new Map();
    prompts = new Map();
    registerTool(name, registration) {
        this.tools.set(name, registration);
        logger.debug(`Registered tool: ${name}`);
    }
    registerResource(name, registration) {
        this.resources.set(name, registration);
        logger.debug(`Registered resource: ${name}`);
    }
    registerPrompt(name, registration) {
        this.prompts.set(name, registration);
        logger.debug(`Registered prompt: ${name}`);
    }
    getTools() {
        return Array.from(this.tools.values());
    }
    getResources() {
        return Array.from(this.resources.values());
    }
    getPrompts() {
        return Array.from(this.prompts.values());
    }
    getTool(name) {
        return this.tools.get(name);
    }
    getResource(name) {
        return this.resources.get(name);
    }
    getPrompt(name) {
        return this.prompts.get(name);
    }
}
/**
 * Schema converter - converts SimpleSchema to Zod RawShape
 */
class SchemaConverter {
    static toZodShape(schema) {
        const zodProps = {};
        for (const [key, value] of Object.entries(schema)) {
            if (typeof value === 'string') {
                switch (value) {
                    case 'string':
                        zodProps[key] = z.string();
                        break;
                    case 'number':
                        zodProps[key] = z.number();
                        break;
                    case 'boolean':
                        zodProps[key] = z.boolean();
                        break;
                    case 'array':
                        zodProps[key] = z.array(z.any());
                        break;
                    case 'object':
                        zodProps[key] = z.record(z.any());
                        break;
                    default:
                        zodProps[key] = z.any();
                }
            }
            else if (value && typeof value === 'object' && value.type === 'object') {
                zodProps[key] = z.object(this.toZodShape(value.properties));
            }
            else {
                zodProps[key] = z.any();
            }
        }
        return zodProps;
    }
}
/**
 * Main QuickMCP Server class
 */
export class QuickMCPServer {
    config;
    registry = new HandlerRegistry();
    mcpServer;
    isStarted = false;
    httpApp;
    httpTransports = new Map();
    constructor(config) {
        this.config = {
            version: '1.0.0',
            transport: 'stdio',
            autoStart: false,
            debug: false,
            ...config
        };
        // Configure logger
        logger.configure({
            level: this.config.debug ? 'debug' : 'info',
            enabled: true,
            useStderr: this.config.transport === 'stdio' // Only use stderr for stdio transport
        });
        // Create MCP server instance
        this.mcpServer = new McpServer({
            name: this.config.name,
            version: this.config.version
        });
        logger.info(`QuickMCP Server created: ${this.config.name}`);
    }
    /**
     * Register a tool with automatic schema conversion
     */
    tool(name, handler, config) {
        const toolConfig = {
            description: config?.description || `Tool: ${name}`,
            title: config?.title || name,
            ...(config?.schema && { schema: config.schema })
        };
        const registration = {
            name,
            config: toolConfig,
            handler: this.wrapToolHandler(handler, name)
        };
        this.registry.registerTool(name, registration);
        this.registerToolWithMCP(registration);
        return this;
    }
    /**
     * Wrap tool handler with error handling and response normalization
     */
    wrapToolHandler(handler, name) {
        return async (args) => {
            try {
                const result = await handler(args);
                return Response.normalize(result);
            }
            catch (error) {
                logger.error(`Tool execution failed: ${name}`, error);
                return Response.response([Response.error(`Tool execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`)]);
            }
        };
    }
    /**
     * Register a resource (static or template)
     */
    resource(name, handler, config) {
        const resourceConfig = {
            uri: config?.uri || `resource://${name}`,
            description: config?.description || `Resource: ${name}`,
            mimeType: config?.mimeType || 'text/plain',
            title: config?.title || name,
            isTemplate: config?.isTemplate || false
        };
        const registration = {
            name,
            config: resourceConfig,
            handler: this.wrapResourceHandler(handler, name)
        };
        this.registry.registerResource(name, registration);
        this.registerResourceWithMCP(registration);
        return this;
    }
    /**
     * Wrap resource handler with error handling
     */
    wrapResourceHandler(handler, name) {
        return async (args) => {
            try {
                return await handler(args);
            }
            catch (error) {
                logger.error(`Resource read failed: ${name}`, error);
                throw new Error(`Resource read failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
        };
    }
    /**
     * Register a prompt
     */
    prompt(name, handler, config) {
        const promptConfig = {
            description: config?.description || `Prompt: ${name}`,
            title: config?.title || name,
            ...(config?.schema && { schema: config.schema })
        };
        const registration = {
            name,
            config: promptConfig,
            handler: this.wrapPromptHandler(handler, name)
        };
        this.registry.registerPrompt(name, registration);
        this.registerPromptWithMCP(registration);
        return this;
    }
    /**
     * Wrap prompt handler with error handling
     */
    wrapPromptHandler(handler, name) {
        return async (args) => {
            try {
                return await handler(args);
            }
            catch (error) {
                logger.error(`Prompt execution failed: ${name}`, error);
                throw new Error(`Prompt execution failed: ${error instanceof Error ? error.message : 'Unknown error'}`);
            }
        };
    }
    /**
     * Register individual tool with MCP server
     */
    registerToolWithMCP(tool) {
        const inputSchema = tool.config.schema ? SchemaConverter.toZodShape(tool.config.schema) : {};
        const toolConfig = {
            description: tool.config.description,
            inputSchema,
            ...(tool.config.title && { title: tool.config.title })
        };
        this.mcpServer.registerTool(tool.name, toolConfig, tool.handler);
    }
    /**
     * Register individual resource with MCP server
     */
    registerResourceWithMCP(resource) {
        const resourceConfig = {
            description: resource.config.description,
            mimeType: resource.config.mimeType,
            ...(resource.config.title && { title: resource.config.title })
        };
        if (resource.config.isTemplate) {
            // Handle resource templates
            const template = new ResourceTemplate(resource.config.uri, { list: undefined });
            this.mcpServer.registerResource(resource.name, template, resourceConfig, async (uri, params) => {
                const result = await resource.handler({ uri: uri.href, params });
                return result;
            });
        }
        else {
            // Handle static resources
            this.mcpServer.registerResource(resource.name, resource.config.uri, resourceConfig, async (uri) => {
                const result = await resource.handler({ uri: uri.href });
                return result;
            });
        }
    }
    /**
     * Register individual prompt with MCP server
     */
    registerPromptWithMCP(prompt) {
        const argsSchema = prompt.config.schema ? SchemaConverter.toZodShape(prompt.config.schema) : {};
        const promptConfig = {
            description: prompt.config.description,
            argsSchema,
            ...(prompt.config.title && { title: prompt.config.title })
        };
        // Wrap handler to ensure proper return type
        this.mcpServer.registerPrompt(prompt.name, promptConfig, async (args) => {
            const result = await prompt.handler(args);
            return result;
        });
    }
    /**
     * Start the server
     */
    async start() {
        if (this.isStarted) {
            logger.warn('Server is already started');
            return;
        }
        try {
            if (this.config.transport === 'stdio') {
                await this.startStdioServer();
            }
            else if (this.config.transport === 'http' || this.config.transport === 'sse') {
                // Note: 'sse' is deprecated name, kept for backwards compatibility
                await this.startHttpServer();
            }
            else {
                throw new Error(`Unsupported transport: ${this.config.transport}`);
            }
            this.isStarted = true;
            logger.info(`QuickMCP Server "${this.config.name}" is running`);
        }
        catch (error) {
            logger.error('Failed to start server', error);
            throw error;
        }
    }
    /**
     * Start STDIO server
     */
    async startStdioServer() {
        const transport = new StdioServerTransport();
        await this.mcpServer.connect(transport);
        logger.info('Server started with STDIO transport');
    }
    /**
     * Start HTTP server
     */
    async startHttpServer() {
        const httpConfig = this.config.http || {};
        const port = httpConfig.port || 3000;
        const enableCors = httpConfig.enableCors !== false;
        const sessionManagement = httpConfig.sessionManagement !== false;
        this.httpApp = express();
        this.httpApp.use(express.json());
        if (enableCors) {
            this.httpApp.use(cors({
                origin: httpConfig.corsOrigin || '*',
                exposedHeaders: ['Mcp-Session-Id'],
                allowedHeaders: ['Content-Type', 'mcp-session-id'],
            }));
        }
        if (sessionManagement) {
            await this.setupSessionManagement();
        }
        else {
            await this.setupStatelessHttp();
        }
        this.httpApp.listen(port, () => {
            logger.info(`HTTP server started on port ${port}`);
        });
    }
    /**
     * Setup session-based HTTP handling
     */
    async setupSessionManagement() {
        this.httpApp.post('/mcp', async (req, res) => {
            const sessionId = req.headers['mcp-session-id'];
            let transport;
            if (sessionId && this.httpTransports.has(sessionId)) {
                transport = this.httpTransports.get(sessionId);
            }
            else if (!sessionId && this.isInitializeRequest(req.body)) {
                transport = new StreamableHTTPServerTransport({
                    sessionIdGenerator: () => randomUUID(),
                    onsessioninitialized: (sessionId) => {
                        this.httpTransports.set(sessionId, transport);
                    }
                });
                transport.onclose = () => {
                    if (transport.sessionId) {
                        this.httpTransports.delete(transport.sessionId);
                    }
                };
                await this.mcpServer.connect(transport);
            }
            else {
                res.status(400).json({
                    jsonrpc: '2.0',
                    error: { code: -32000, message: 'Bad Request: No valid session ID provided' },
                    id: null,
                });
                return;
            }
            await transport.handleRequest(req, res, req.body);
        });
        // Handle SSE for notifications
        this.httpApp.get('/mcp', async (req, res) => {
            const sessionId = req.headers['mcp-session-id'];
            if (!sessionId || !this.httpTransports.has(sessionId)) {
                res.status(400).send('Invalid or missing session ID');
                return;
            }
            const transport = this.httpTransports.get(sessionId);
            await transport.handleRequest(req, res);
        });
        // Handle session termination
        this.httpApp.delete('/mcp', async (req, res) => {
            const sessionId = req.headers['mcp-session-id'];
            if (!sessionId || !this.httpTransports.has(sessionId)) {
                res.status(400).send('Invalid or missing session ID');
                return;
            }
            const transport = this.httpTransports.get(sessionId);
            await transport.handleRequest(req, res);
        });
    }
    /**
     * Setup stateless HTTP handling
     */
    async setupStatelessHttp() {
        this.httpApp.post('/mcp', async (req, res) => {
            try {
                const server = new McpServer({ name: this.config.name, version: this.config.version });
                // Re-register all handlers with the new server instance
                this.registry.getTools().forEach(tool => {
                    const inputSchema = tool.config.schema ? SchemaConverter.toZodShape(tool.config.schema) : {};
                    const toolConfig = {
                        description: tool.config.description,
                        inputSchema,
                        ...(tool.config.title && { title: tool.config.title })
                    };
                    server.registerTool(tool.name, toolConfig, tool.handler);
                });
                this.registry.getResources().forEach(resource => {
                    const resourceConfig = {
                        description: resource.config.description,
                        mimeType: resource.config.mimeType,
                        ...(resource.config.title && { title: resource.config.title })
                    };
                    if (resource.config.isTemplate) {
                        const template = new ResourceTemplate(resource.config.uri, { list: undefined });
                        server.registerResource(resource.name, template, resourceConfig, resource.handler);
                    }
                    else {
                        server.registerResource(resource.name, resource.config.uri, resourceConfig, resource.handler);
                    }
                });
                this.registry.getPrompts().forEach(prompt => {
                    const argsSchema = prompt.config.schema ? SchemaConverter.toZodShape(prompt.config.schema) : {};
                    const promptConfig = {
                        description: prompt.config.description,
                        argsSchema,
                        ...(prompt.config.title && { title: prompt.config.title })
                    };
                    server.registerPrompt(prompt.name, promptConfig, prompt.handler);
                });
                const transport = new StreamableHTTPServerTransport({ sessionIdGenerator: undefined });
                res.on('close', () => {
                    transport.close();
                    server.close();
                });
                await server.connect(transport);
                await transport.handleRequest(req, res, req.body);
            }
            catch (error) {
                logger.error('Error handling MCP request:', error);
                if (!res.headersSent) {
                    res.status(500).json({
                        jsonrpc: '2.0',
                        error: { code: -32603, message: 'Internal server error' },
                        id: null,
                    });
                }
            }
        });
        // Stateless mode doesn't support SSE or session termination
        this.httpApp.get('/mcp', (req, res) => {
            res.status(405).json({
                jsonrpc: "2.0",
                error: { code: -32000, message: "Method not allowed." },
                id: null
            });
        });
        this.httpApp.delete('/mcp', (req, res) => {
            res.status(405).json({
                jsonrpc: "2.0",
                error: { code: -32000, message: "Method not allowed." },
                id: null
            });
        });
    }
    /**
     * Check if request is an initialize request
     */
    isInitializeRequest(body) {
        return body && body.method === 'initialize';
    }
    /**
     * Stop the server
     */
    async stop() {
        if (!this.isStarted) {
            return;
        }
        try {
            // Close all HTTP transports
            for (const transport of this.httpTransports.values()) {
                transport.close();
            }
            this.httpTransports.clear();
            // Close MCP server
            this.mcpServer.close();
            this.isStarted = false;
            logger.info('Server stopped');
        }
        catch (error) {
            logger.error('Error stopping server', error);
            throw error;
        }
    }
    /**
     * Get server statistics
     */
    getStats() {
        return {
            name: this.config.name,
            version: this.config.version,
            transport: this.config.transport,
            isStarted: this.isStarted,
            tools: this.registry.getTools().length,
            resources: this.registry.getResources().length,
            prompts: this.registry.getPrompts().length,
            httpSessions: this.httpTransports.size
        };
    }
}
/**
 * Factory function to create a QuickMCP server
 */
export const createServer = (config) => {
    return new QuickMCPServer(config);
};
//# sourceMappingURL=server.js.map