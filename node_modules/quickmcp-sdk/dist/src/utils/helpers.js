/**
 * Utility helpers for QuickMCP
 * Common patterns and shortcuts for MCP development
 */
import { Response } from './response.js';
/**
 * Schema builders for common patterns
 */
export const Schema = {
    /**
     * String field
     */
    string(description) {
        return 'string';
    },
    /**
     * Number field
     */
    number(description) {
        return 'number';
    },
    /**
     * Boolean field
     */
    boolean(description) {
        return 'boolean';
    },
    /**
     * Array field
     */
    array(description) {
        return 'array';
    },
    /**
     * Object field with properties
     */
    object(properties, required) {
        return {
            type: 'object',
            properties,
            ...(required && { required })
        };
    },
    /**
     * Quick schema builder
     */
    build(definition) {
        return definition;
    }
};
/**
 * Common response builders
 */
export const Responses = {
    /**
     * Success response with data
     */
    success(data, message) {
        const content = [Response.json(data)];
        if (message) {
            content.unshift(Response.text(message));
        }
        return Response.response(content);
    },
    /**
     * Error response
     */
    error(message, details) {
        const content = [Response.error(message)];
        if (details) {
            content.push(Response.json(details));
        }
        return Response.response(content);
    },
    /**
     * List response
     */
    list(items, message) {
        const content = [];
        if (message) {
            content.push(Response.text(message));
        }
        content.push(Response.json({ items, count: items.length }));
        return Response.response(content);
    },
    /**
     * File/resource links response
     */
    links(links) {
        const content = links.map(link => Response.link(link.uri, link.name, link.mimeType, link.description));
        return Response.response(content);
    }
};
/**
 * Resource helpers
 */
export const Resources = {
    /**
     * Create a simple text resource
     */
    text(uri, content, mimeType = 'text/plain') {
        return {
            contents: [{
                    uri,
                    text: content,
                    mimeType
                }]
        };
    },
    /**
     * Create a JSON resource
     */
    json(uri, data) {
        return {
            contents: [{
                    uri,
                    text: JSON.stringify(data, null, 2),
                    mimeType: 'application/json'
                }]
        };
    },
    /**
     * Create a file resource
     */
    file(uri, content, mimeType) {
        return {
            contents: [{
                    uri,
                    text: content,
                    ...(mimeType && { mimeType })
                }]
        };
    }
};
/**
 * Prompt helpers
 */
export const Prompts = {
    /**
     * Create a simple user prompt
     */
    user(text) {
        return {
            messages: [{
                    role: 'user',
                    content: { type: 'text', text }
                }]
        };
    },
    /**
     * Create an assistant prompt
     */
    assistant(text) {
        return {
            messages: [{
                    role: 'assistant',
                    content: { type: 'text', text }
                }]
        };
    },
    /**
     * Create a conversation prompt
     */
    conversation(messages) {
        return {
            messages: messages.map(msg => ({
                role: msg.role,
                content: { type: 'text', text: msg.text }
            }))
        };
    }
};
/**
 * Validation helpers
 */
export const Validate = {
    /**
     * Validate required fields
     */
    required(obj, fields) {
        for (const field of fields) {
            if (!(field in obj) || obj[field] === undefined || obj[field] === null) {
                throw new Error(`Missing required field: ${field}`);
            }
        }
    },
    /**
     * Validate email format
     */
    email(email) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        return emailRegex.test(email);
    },
    /**
     * Validate URL format
     */
    url(url) {
        try {
            new URL(url);
            return true;
        }
        catch {
            return false;
        }
    }
};
/**
 * Async helpers
 */
export const Async = {
    /**
     * Retry a function with exponential backoff
     */
    async retry(fn, maxRetries = 3, baseDelay = 1000) {
        let lastError;
        for (let i = 0; i <= maxRetries; i++) {
            try {
                return await fn();
            }
            catch (error) {
                lastError = error;
                if (i === maxRetries)
                    break;
                const delay = baseDelay * Math.pow(2, i);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
        throw lastError;
    },
    /**
     * Timeout wrapper
     */
    async timeout(promise, ms) {
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error(`Operation timed out after ${ms}ms`)), ms);
        });
        return Promise.race([promise, timeoutPromise]);
    }
};
/**
 * HTTP helpers for making external API calls
 */
export const Http = {
    /**
     * Simple GET request
     */
    async get(url, headers) {
        const response = await fetch(url, headers ? { headers } : {});
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json();
    },
    /**
     * Simple POST request
     */
    async post(url, data, headers) {
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', ...headers },
            body: JSON.stringify(data)
        });
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return response.json();
    }
};
//# sourceMappingURL=helpers.js.map