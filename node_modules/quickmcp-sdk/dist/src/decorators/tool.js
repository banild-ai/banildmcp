/**
 * Decorators for QuickMCP - Modern decorator-based API
 */
import { Response } from '../utils/response.js';
// Global registries for decorated functions
const toolRegistry = new Map();
const resourceRegistry = new Map();
const promptRegistry = new Map();
/**
 * Tool decorator - marks a method as an MCP tool
 */
export function tool(config) {
    return function (target, propertyKey, descriptor) {
        const originalMethod = descriptor?.value || target[propertyKey];
        const toolName = propertyKey;
        // Handle string shorthand
        const toolConfig = typeof config === 'string'
            ? { description: config }
            : config;
        // Wrap the original method to ensure proper return format
        const wrappedHandler = async (args) => {
            const result = await originalMethod.apply(target, [args]);
            return Response.normalize(result);
        };
        // Register the tool
        toolRegistry.set(toolName, {
            config: {
                ...toolConfig,
                title: toolConfig.title || toolName
            },
            handler: wrappedHandler
        });
        return descriptor;
    };
}
/**
 * Resource decorator - marks a method as an MCP resource
 */
export function resource(config) {
    return function (target, propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        const resourceName = propertyKey;
        // Handle string shorthand
        const resourceConfig = typeof config === 'string'
            ? { uri: `resource://${resourceName}`, description: config }
            : config;
        // Wrap the original method
        const wrappedHandler = async (args) => {
            return await originalMethod.apply(target, [args]);
        };
        // Register the resource
        resourceRegistry.set(resourceName, {
            config: {
                ...resourceConfig,
                title: resourceConfig.title || resourceName
            },
            handler: wrappedHandler
        });
        return descriptor;
    };
}
/**
 * Prompt decorator - marks a method as an MCP prompt
 */
export function prompt(config) {
    return function (target, propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        const promptName = propertyKey;
        // Handle string shorthand
        const promptConfig = typeof config === 'string'
            ? { description: config }
            : config;
        // Wrap the original method
        const wrappedHandler = async (args) => {
            return await originalMethod.apply(target, [args]);
        };
        // Register the prompt
        promptRegistry.set(promptName, {
            config: {
                ...promptConfig,
                title: promptConfig.title || promptName
            },
            handler: wrappedHandler
        });
        return descriptor;
    };
}
/**
 * Schema helper for creating simple schemas
 */
export function schema(definition) {
    return definition;
}
/**
 * Get all registered tools
 */
export function getRegisteredTools() {
    return toolRegistry;
}
/**
 * Get all registered resources
 */
export function getRegisteredResources() {
    return resourceRegistry;
}
/**
 * Get all registered prompts
 */
export function getRegisteredPrompts() {
    return promptRegistry;
}
/**
 * Clear all registries (for testing)
 */
export function clearAllRegistries() {
    toolRegistry.clear();
    resourceRegistry.clear();
    promptRegistry.clear();
}
/**
 * Auto-register all decorated methods with a server
 */
export function autoRegister(server, instance) {
    // Register tools
    for (const [name, registration] of toolRegistry) {
        server.tool(name, registration.handler, registration.config);
    }
    // Register resources
    for (const [name, registration] of resourceRegistry) {
        server.resource(name, registration.handler, registration.config);
    }
    // Register prompts
    for (const [name, registration] of promptRegistry) {
        server.prompt(name, registration.handler, registration.config);
    }
}
//# sourceMappingURL=tool.js.map